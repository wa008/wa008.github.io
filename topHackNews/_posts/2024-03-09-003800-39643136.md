{
  "by" : "abelanger",
  "descendants" : 96,
  "id" : 39643136,
  "kids" : [ 39643991, 39645209, 39644543, 39647915, 39646725, 39645379, 39647943, 39644200, 39643927, 39646300, 39646970, 39645312, 39647366, 39644741, 39643642, 39645974, 39645091, 39643364, 39643782, 39646077, 39647257, 39643575, 39643868, 39644734, 39643427, 39645672, 39643632, 39646807, 39646015, 39645296, 39646582, 39643464 ],
  "score" : 292,
  "text" : "Hello HN, we&#x27;re Gabe and Alexander from Hatchet (<a href=\"https:&#x2F;&#x2F;hatchet.run\">https:&#x2F;&#x2F;hatchet.run</a>), we&#x27;re working on an open-source, distributed task queue. It&#x27;s an alternative to tools like Celery for Python and BullMQ for Node.js, primarily focused on reliability and observability. It uses Postgres for the underlying queue.<p>Why build another managed queue? We wanted to build something with the benefits of full transactional enqueueing - particularly for dependent, DAG-style execution - and felt strongly that Postgres solves for 99.9% of queueing use-cases better than most alternatives (Celery uses Redis or RabbitMQ as a broker, BullMQ uses Redis). Since the introduction of SKIP LOCKED and the milestones of recent PG releases (like active-active replication), it&#x27;s becoming more feasible to horizontally scale Postgres across multiple regions and vertically scale to 10k TPS or more. Many queues (like BullMQ) are built on Redis and data loss can occur when suffering OOM if you&#x27;re not careful, and using PG helps avoid an entire class of problems.<p>We also wanted something that was significantly easier to use and debug for application developers. A lot of times the burden of building task observability falls on the infra&#x2F;platform team (for example, asking the infra team to build a Grafana view for their tasks based on exported prom metrics). We&#x27;re building this type of observability directly into Hatchet.<p>What do we mean by &quot;distributed&quot;? You can run workers (the instances which run tasks) across multiple VMs, clusters and regions - they are remotely invoked via a long-lived gRPC connection with the Hatchet queue. We&#x27;ve attempted to optimize our latency to get our task start times down to 25-50ms and much more optimization is on the roadmap.<p>We also support a number of extra features that you&#x27;d expect, like retries, timeouts, cron schedules, dependent tasks. A few things we&#x27;re currently working on - we use RabbitMQ (confusing, yes) for pub&#x2F;sub between engine components and would prefer to just use Postgres, but didn&#x27;t want to spend additional time on the exchange logic until we built a stable underlying queue. We are also considering the use of NATS for engine-engine and engine-worker connections.<p>We&#x27;d greatly appreciate any feedback you have and hope you get the chance to try out Hatchet.",
  "time" : 1709917655,
  "title" : "Show HN: Hatchet â€“ Open-source distributed task queue",
  "type" : "story",
  "url" : "https://github.com/hatchet-dev/hatchet"
}
